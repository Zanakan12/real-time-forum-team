
import { checkProfileImage } from "/static/js/imagepath.js";
import { fetchUserData } from "/static/js/app.js";
export let socket;

// Connexion WebSocket
export async function connectWebSocket(username) {
  if (socket && socket.readyState === WebSocket.OPEN) {
    console.log("WebSocket d√©j√† connect√©.");
    return;
  }

  socket = new WebSocket(`wss://localhost:8080/ws?username=${username}`);

  socket.onopen = () => {
    console.log("‚úÖ Connexion WebSocket √©tablie !");
    if (typeof fetchConnectedUsers === "function") {
      fetchConnectedUsers();
    }
  };

  socket.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      if (msg.type === "user_list") {
        const users = JSON.parse(msg.content);
        updateUserList(users);
      } else if (msg.type === "message") {
        // G√®re les messages normaux ici
      }
    } catch (error) {
      console.error("Erreur de parsing WebSocket :", error);
    }
  };

  socket.onclose = (event) => {
    console.warn("‚ö†Ô∏è Connexion WebSocket ferm√©e.", event.reason);
    setTimeout(() => {
      console.log("üîÑ Tentative de reconnexion...");
      connectWebSocket(username);
    }, 3000); // Tentative de reconnexion apr√®s 3 secondes
  };

  socket.onerror = (error) => {
    console.error("‚ùå Erreur WebSocket :", error);
    socket.close();
  };
}


let lastFetchTime = 0;
const FETCH_INTERVAL = 5000; // 5 secondes minimum entre chaque appel

export async function fetchConnectedUsers() {
  const now = Date.now();
  if (now - lastFetchTime < FETCH_INTERVAL) {
    console.warn("‚è≥ Attente avant le prochain fetch...");
    return;
  }
  lastFetchTime = now;

  try {
    const response = await fetch("https://localhost:8080/api/users-connected");
    if (response.status === 429) {
      console.warn("‚ö†Ô∏è Trop de requ√™tes ! Attente...");
      return;
    }

    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("application/json")) {
      console.error("‚ùå R√©ponse inattendue :", await response.text());
      return;
    }

    const users = await response.json();
    if (!users) return;

    updateUserList(JSON.parse(users));
    fetchAllUsers(JSON.parse(users));
  } catch (error) {
    console.error("‚ùå Erreur lors du fetch :", error);
  }
}



// Mettre √† jour la liste des utilisateurs connect√©s
async function updateUserList(users) {
  console.log("üë• Mise √† jour de la liste des utilisateurs :", users);
  const usersList = document.getElementById("users-online");
  usersList.innerHTML = "";
  let username = await fetchUserData()
  if (!username) {
    return
  }
  users.forEach((user) => {
    const li = document.createElement("li");
    li.classList.add("selectUser", "online");
    li.id = `${user}`;
    checkProfileImage(user, li);
    if (user === username.username) li.style.setProperty("--before-content", '"Vous"');
    else li.style.setProperty("--before-content", `"${user}"`);
    usersList.appendChild(li);
  });
}

export async function fetchAllUsers(connectedUsers) {
  try {
    const response = await fetch("https://localhost:8080/api/last-messages");
    if (!response.ok) throw new Error("Erreur lors du fetch");

    const users = await response.json();
    const currentUser = await fetchUserData();

    const usersOfflineList = document.getElementById("users-offline");

    console.log(users)

    usersOfflineList.innerHTML = "";

    users
      .filter((u) => u.username && u.username !== currentUser.username)
      .sort((a, b) => {
        if (!a.last_message) return 1;
        if (!b.last_message) return -1;
        return new Date(b.last_message) - new Date(a.last_message);
      })
      .forEach((user) => {
        const li = document.createElement("li");
        li.classList.add("selectUser", "short");
        li.id = user.username;

        checkProfileImage(user.username, li);
        li.style.setProperty("--before-content", `"${user.username}"`);


            console.log(connectedUsers,users);
            li.classList.add("offline");
            usersOfflineList.appendChild(li);
        


      });


  } catch (err) {
    console.error("Erreur lors du fetch last messages :", err);
  }
}